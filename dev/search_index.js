var documenterSearchIndex = {"docs":
[{"location":"blackbox/#BlackBox-Adversarial-Algorithms","page":"BlackBox","title":"BlackBox Adversarial Algorithms","text":"","category":"section"},{"location":"blackbox/","page":"BlackBox","title":"BlackBox","text":"SimBA","category":"page"},{"location":"whitebox/#WhiteBox-Adversarial-Algorithms","page":"WhiteBox","title":"WhiteBox Adversarial Algorithms","text":"","category":"section"},{"location":"whitebox/","page":"WhiteBox","title":"WhiteBox","text":"FGSM\nPGD\nJSMA\nCW\nDeepFool","category":"page"},{"location":"whitebox/#Adversarial.FGSM","page":"WhiteBox","title":"Adversarial.FGSM","text":"FGSM(model, loss, x, y; ϵ = 0.1, clamp_range = (0, 1))\n\nFast Gradient Sign Method (FGSM) is a method of creating adversarial examples by pushing the input in the direction of the gradient and bounded by the ε parameter.\n\nThis method was proposed by Goodfellow et al. 2014 (https://arxiv.org/abs/1412.6572)\n\nArguments:\n\nmodel: The model to base the attack upon.\nloss: The loss function to use. This assumes that the loss function includes   the predict function, i.e. loss(x, y) = crossentropy(model(x), y).\nx: The input to be perturbed by the FGSM algorithm.\ny: The 'true' label of the input.\nϵ: The amount of perturbation to apply.\nclamp_range: Tuple consisting of the lower and upper values to clamp the input.\n\n\n\n\n\n","category":"function"},{"location":"whitebox/#Adversarial.PGD","page":"WhiteBox","title":"Adversarial.PGD","text":"PGD(model, loss, x, y; ϵ = 10, step_size = 0.1, iters = 100, clamp_range = (0, 1))\n\nProjected Gradient Descent (PGD) is an itrative variant of FGSM with a random point. For every step the FGSM algorithm moves the input in the direction of the gradient bounded in the l∞ norm. (https://arxiv.org/pdf/1706.06083.pdf)\n\nArguments:\n\nmodel: The model to base teh attack upon.\nloss: the loss function to use, assuming that it includes the prediction function   i.e. loss(x, y) = crossentropy(m(x), y)\nx: The input to be perturbed.\ny: the ground truth for x.\nϵ: The bound around x.\nstep_size: The ϵ value in the FGSM step.\niters: The maximum number of iterations to run the algorithm for.\nclamp_range: The lower and upper values to clamp the input to.\n\n\n\n\n\n","category":"function"},{"location":"whitebox/#Adversarial.JSMA","page":"WhiteBox","title":"Adversarial.JSMA","text":"JSMA(model, x, t; Υ, θ)\n\nJacobian Saliency Map Algorithm (JSMA), craft adversarial examples by modifying a very small amount of pixels. These pixels are selected via the jacobian matrix of the output w.r.t. the input of the network. (https://arxiv.org/pdf/1511.07528.pdf)\n\nArguments:\n\nmodel: The model to create adversarial examples for.\nx: The original input data\nt: Index corrosponding to the target class (this is a targeted attack).\nΥ: The maximum amount of distortion\nθ: The amount by which each feature is perturbed.\n\n\n\n\n\n","category":"function"},{"location":"whitebox/#Adversarial.CW","page":"WhiteBox","title":"Adversarial.CW","text":"CW(model, x, t; dist = euclidean, c = 0.1)\n\nCarlini & Wagner's (CW) method for generating adversarials through the optimisation of a loss function against a target class. Here we consider the F6 variant loss function. (https://arxiv.org/pdf/1608.04644.pdf)\n\nArguments:\n\nmodel: The model to attack.\nx: The original input data\nt: Index label corrosponding to the target class.\ndist: The distance measure to use L0, L2, L∞. Assumes this is from the   Distances.jl library or some other callable function.\nc: value for the contribution of the missclassification in the error function.\n\n\n\n\n\n","category":"function"},{"location":"whitebox/#Adversarial.DeepFool","page":"WhiteBox","title":"Adversarial.DeepFool","text":"DeepFool(model, x, overshoot = 0.02, max_iter = 50)\n\nMoosavi-Dezfooli et al.'s (https://arxiv.org/pdf/1511.04599.pdf) DeepFool method.\n\nArguments:\n\nmodel: The flux model to attack.\nx: An array of input images to create adversarial examples for.\novershoot: The halting criteria to prevent vanishing gradient.\nmax_iter: The maximum iterations for the algorithm.\n\n\n\n\n\n","category":"function"}]
}
